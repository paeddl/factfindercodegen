<?php
/**
 * RecordsApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FACT-Finder REST-API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v5
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.46
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\FactFinder;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * RecordsApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RecordsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation compareUsingGET
     *
     * Compare products
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CompareResult
     */
    public function compareUsingGET($channel, $id = null, $ids_only = 'false', $purchaser_id = null)
    {
        list($response) = $this->compareUsingGETWithHttpInfo($channel, $id, $ids_only, $purchaser_id);
        return $response;
    }

    /**
     * Operation compareUsingGETWithHttpInfo
     *
     * Compare products
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CompareResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function compareUsingGETWithHttpInfo($channel, $id = null, $ids_only = 'false', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\CompareResult';
        $request = $this->compareUsingGETRequest($channel, $id, $ids_only, $purchaser_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CompareResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation compareUsingGETAsync
     *
     * Compare products
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compareUsingGETAsync($channel, $id = null, $ids_only = 'false', $purchaser_id = null)
    {
        return $this->compareUsingGETAsyncWithHttpInfo($channel, $id, $ids_only, $purchaser_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation compareUsingGETAsyncWithHttpInfo
     *
     * Compare products
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compareUsingGETAsyncWithHttpInfo($channel, $id = null, $ids_only = 'false', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\CompareResult';
        $request = $this->compareUsingGETRequest($channel, $id, $ids_only, $purchaser_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'compareUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function compareUsingGETRequest($channel, $id = null, $ids_only = 'false', $purchaser_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling compareUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/compare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($ids_only !== null) {
            $queryParams['idsOnly'] = ObjectSerializer::toQueryValue($ids_only, null);
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCustomerPricesUsingDELETE
     *
     * Delete customer prices
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeleteResult[]
     */
    public function deleteCustomerPricesUsingDELETE($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        list($response) = $this->deleteCustomerPricesUsingDELETEWithHttpInfo($channel, $body, $id, $id_type, $verbose);
        return $response;
    }

    /**
     * Operation deleteCustomerPricesUsingDELETEWithHttpInfo
     *
     * Delete customer prices
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeleteResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomerPricesUsingDELETEWithHttpInfo($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteCustomerPricesUsingDELETERequest($channel, $body, $id, $id_type, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeleteResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCustomerPricesUsingDELETEAsync
     *
     * Delete customer prices
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomerPricesUsingDELETEAsync($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        return $this->deleteCustomerPricesUsingDELETEAsyncWithHttpInfo($channel, $body, $id, $id_type, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomerPricesUsingDELETEAsyncWithHttpInfo
     *
     * Delete customer prices
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomerPricesUsingDELETEAsyncWithHttpInfo($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteCustomerPricesUsingDELETERequest($channel, $body, $id, $id_type, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCustomerPricesUsingDELETE'
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCustomerPricesUsingDELETERequest($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling deleteCustomerPricesUsingDELETE'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/customerprices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGeoUsingDELETE
     *
     * Delete geo data
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeleteResult[]
     */
    public function deleteGeoUsingDELETE($channel, $body = null, $id = null, $verbose = 'false')
    {
        list($response) = $this->deleteGeoUsingDELETEWithHttpInfo($channel, $body, $id, $verbose);
        return $response;
    }

    /**
     * Operation deleteGeoUsingDELETEWithHttpInfo
     *
     * Delete geo data
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeleteResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGeoUsingDELETEWithHttpInfo($channel, $body = null, $id = null, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteGeoUsingDELETERequest($channel, $body, $id, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeleteResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGeoUsingDELETEAsync
     *
     * Delete geo data
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGeoUsingDELETEAsync($channel, $body = null, $id = null, $verbose = 'false')
    {
        return $this->deleteGeoUsingDELETEAsyncWithHttpInfo($channel, $body, $id, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGeoUsingDELETEAsyncWithHttpInfo
     *
     * Delete geo data
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGeoUsingDELETEAsyncWithHttpInfo($channel, $body = null, $id = null, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteGeoUsingDELETERequest($channel, $body, $id, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGeoUsingDELETE'
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteGeoUsingDELETERequest($channel, $body = null, $id = null, $verbose = 'false')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling deleteGeoUsingDELETE'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/geo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMarketUsingDELETE
     *
     * Delete geo market
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteMarketRequest $body deleteMarketRequest (optional)
     * @param  string[] $market_id The ids of the markets which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeleteResult[]
     */
    public function deleteMarketUsingDELETE($channel, $body = null, $market_id = null, $verbose = 'false')
    {
        list($response) = $this->deleteMarketUsingDELETEWithHttpInfo($channel, $body, $market_id, $verbose);
        return $response;
    }

    /**
     * Operation deleteMarketUsingDELETEWithHttpInfo
     *
     * Delete geo market
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteMarketRequest $body deleteMarketRequest (optional)
     * @param  string[] $market_id The ids of the markets which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeleteResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMarketUsingDELETEWithHttpInfo($channel, $body = null, $market_id = null, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteMarketUsingDELETERequest($channel, $body, $market_id, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeleteResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMarketUsingDELETEAsync
     *
     * Delete geo market
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteMarketRequest $body deleteMarketRequest (optional)
     * @param  string[] $market_id The ids of the markets which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMarketUsingDELETEAsync($channel, $body = null, $market_id = null, $verbose = 'false')
    {
        return $this->deleteMarketUsingDELETEAsyncWithHttpInfo($channel, $body, $market_id, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMarketUsingDELETEAsyncWithHttpInfo
     *
     * Delete geo market
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteMarketRequest $body deleteMarketRequest (optional)
     * @param  string[] $market_id The ids of the markets which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMarketUsingDELETEAsyncWithHttpInfo($channel, $body = null, $market_id = null, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteMarketUsingDELETERequest($channel, $body, $market_id, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMarketUsingDELETE'
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteMarketRequest $body deleteMarketRequest (optional)
     * @param  string[] $market_id The ids of the markets which should be deleted. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMarketUsingDELETERequest($channel, $body = null, $market_id = null, $verbose = 'false')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling deleteMarketUsingDELETE'
            );
        }

        $resourcePath = '/rest/v5/markets/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUsingDELETE
     *
     * Delete records
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeleteResult[]
     */
    public function deleteUsingDELETE($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        list($response) = $this->deleteUsingDELETEWithHttpInfo($channel, $body, $id, $id_type, $verbose);
        return $response;
    }

    /**
     * Operation deleteUsingDELETEWithHttpInfo
     *
     * Delete records
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeleteResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUsingDELETEWithHttpInfo($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteUsingDELETERequest($channel, $body, $id, $id_type, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeleteResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUsingDELETEAsync
     *
     * Delete records
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUsingDELETEAsync($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        return $this->deleteUsingDELETEAsyncWithHttpInfo($channel, $body, $id, $id_type, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUsingDELETEAsyncWithHttpInfo
     *
     * Delete records
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteUsingDELETEAsyncWithHttpInfo($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeleteResult[]';
        $request = $this->deleteUsingDELETERequest($channel, $body, $id, $id_type, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUsingDELETE'
     *
     * @param  string $channel channel (required)
     * @param  \Swagger\Client\Model\DeleteRequest $body deleteRequest (optional)
     * @param  string[] $id The ids from the records which should be deleted. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteUsingDELETERequest($channel, $body = null, $id = null, $id_type = 'productNumber', $verbose = 'false')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling deleteUsingDELETE'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerPricesUsingGET
     *
     * Get customer specific prices
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which customer prices should be returned. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CustomerPriceRecord[]
     */
    public function getCustomerPricesUsingGET($channel, $id, $id_type = 'productNumber')
    {
        list($response) = $this->getCustomerPricesUsingGETWithHttpInfo($channel, $id, $id_type);
        return $response;
    }

    /**
     * Operation getCustomerPricesUsingGETWithHttpInfo
     *
     * Get customer specific prices
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which customer prices should be returned. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CustomerPriceRecord[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerPricesUsingGETWithHttpInfo($channel, $id, $id_type = 'productNumber')
    {
        $returnType = '\Swagger\Client\Model\CustomerPriceRecord[]';
        $request = $this->getCustomerPricesUsingGETRequest($channel, $id, $id_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CustomerPriceRecord[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerPricesUsingGETAsync
     *
     * Get customer specific prices
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which customer prices should be returned. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerPricesUsingGETAsync($channel, $id, $id_type = 'productNumber')
    {
        return $this->getCustomerPricesUsingGETAsyncWithHttpInfo($channel, $id, $id_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerPricesUsingGETAsyncWithHttpInfo
     *
     * Get customer specific prices
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which customer prices should be returned. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerPricesUsingGETAsyncWithHttpInfo($channel, $id, $id_type = 'productNumber')
    {
        $returnType = '\Swagger\Client\Model\CustomerPriceRecord[]';
        $request = $this->getCustomerPricesUsingGETRequest($channel, $id, $id_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerPricesUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which customer prices should be returned. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to productNumber)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomerPricesUsingGETRequest($channel, $id, $id_type = 'productNumber')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getCustomerPricesUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getCustomerPricesUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/customerprices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDetailPageUsingGET
     *
     * Get the detail page
     *
     * @param  string $channel channel (required)
     * @param  string $id The id for which the detailpage should be returned. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results_recommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  int $max_results_similar_products Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     * @param  bool $with_campaigns withCampaigns (optional, default to true)
     * @param  bool $with_recommendations withRecommendations (optional, default to true)
     * @param  bool $with_record withRecord (optional, default to true)
     * @param  bool $with_similar_products withSimilarProducts (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DetailPage
     */
    public function getDetailPageUsingGET($channel, $id, $exclude_products_not_in_range = null, $id_type = 'id', $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = '5', $max_distance = null, $max_results_recommendations = '0', $max_results_similar_products = '10', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null, $with_campaigns = 'true', $with_recommendations = 'true', $with_record = 'true', $with_similar_products = 'true')
    {
        list($response) = $this->getDetailPageUsingGETWithHttpInfo($channel, $id, $exclude_products_not_in_range, $id_type, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $max_results_recommendations, $max_results_similar_products, $purchaser_id, $sid, $use_personalization, $user_id, $with_campaigns, $with_recommendations, $with_record, $with_similar_products);
        return $response;
    }

    /**
     * Operation getDetailPageUsingGETWithHttpInfo
     *
     * Get the detail page
     *
     * @param  string $channel channel (required)
     * @param  string $id The id for which the detailpage should be returned. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results_recommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  int $max_results_similar_products Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     * @param  bool $with_campaigns withCampaigns (optional, default to true)
     * @param  bool $with_recommendations withRecommendations (optional, default to true)
     * @param  bool $with_record withRecord (optional, default to true)
     * @param  bool $with_similar_products withSimilarProducts (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DetailPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDetailPageUsingGETWithHttpInfo($channel, $id, $exclude_products_not_in_range = null, $id_type = 'id', $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = '5', $max_distance = null, $max_results_recommendations = '0', $max_results_similar_products = '10', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null, $with_campaigns = 'true', $with_recommendations = 'true', $with_record = 'true', $with_similar_products = 'true')
    {
        $returnType = '\Swagger\Client\Model\DetailPage';
        $request = $this->getDetailPageUsingGETRequest($channel, $id, $exclude_products_not_in_range, $id_type, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $max_results_recommendations, $max_results_similar_products, $purchaser_id, $sid, $use_personalization, $user_id, $with_campaigns, $with_recommendations, $with_record, $with_similar_products);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DetailPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDetailPageUsingGETAsync
     *
     * Get the detail page
     *
     * @param  string $channel channel (required)
     * @param  string $id The id for which the detailpage should be returned. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results_recommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  int $max_results_similar_products Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     * @param  bool $with_campaigns withCampaigns (optional, default to true)
     * @param  bool $with_recommendations withRecommendations (optional, default to true)
     * @param  bool $with_record withRecord (optional, default to true)
     * @param  bool $with_similar_products withSimilarProducts (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDetailPageUsingGETAsync($channel, $id, $exclude_products_not_in_range = null, $id_type = 'id', $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = '5', $max_distance = null, $max_results_recommendations = '0', $max_results_similar_products = '10', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null, $with_campaigns = 'true', $with_recommendations = 'true', $with_record = 'true', $with_similar_products = 'true')
    {
        return $this->getDetailPageUsingGETAsyncWithHttpInfo($channel, $id, $exclude_products_not_in_range, $id_type, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $max_results_recommendations, $max_results_similar_products, $purchaser_id, $sid, $use_personalization, $user_id, $with_campaigns, $with_recommendations, $with_record, $with_similar_products)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDetailPageUsingGETAsyncWithHttpInfo
     *
     * Get the detail page
     *
     * @param  string $channel channel (required)
     * @param  string $id The id for which the detailpage should be returned. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results_recommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  int $max_results_similar_products Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     * @param  bool $with_campaigns withCampaigns (optional, default to true)
     * @param  bool $with_recommendations withRecommendations (optional, default to true)
     * @param  bool $with_record withRecord (optional, default to true)
     * @param  bool $with_similar_products withSimilarProducts (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDetailPageUsingGETAsyncWithHttpInfo($channel, $id, $exclude_products_not_in_range = null, $id_type = 'id', $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = '5', $max_distance = null, $max_results_recommendations = '0', $max_results_similar_products = '10', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null, $with_campaigns = 'true', $with_recommendations = 'true', $with_record = 'true', $with_similar_products = 'true')
    {
        $returnType = '\Swagger\Client\Model\DetailPage';
        $request = $this->getDetailPageUsingGETRequest($channel, $id, $exclude_products_not_in_range, $id_type, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $max_results_recommendations, $max_results_similar_products, $purchaser_id, $sid, $use_personalization, $user_id, $with_campaigns, $with_recommendations, $with_record, $with_similar_products);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDetailPageUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string $id The id for which the detailpage should be returned. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results_recommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  int $max_results_similar_products Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     * @param  bool $with_campaigns withCampaigns (optional, default to true)
     * @param  bool $with_recommendations withRecommendations (optional, default to true)
     * @param  bool $with_record withRecord (optional, default to true)
     * @param  bool $with_similar_products withSimilarProducts (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDetailPageUsingGETRequest($channel, $id, $exclude_products_not_in_range = null, $id_type = 'id', $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = '5', $max_distance = null, $max_results_recommendations = '0', $max_results_similar_products = '10', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null, $with_campaigns = 'true', $with_recommendations = 'true', $with_record = 'true', $with_similar_products = 'true')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getDetailPageUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDetailPageUsingGET'
            );
        }

        $resourcePath = '/rest/v5/detail/{channel}/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($ids_only !== null) {
            $queryParams['idsOnly'] = ObjectSerializer::toQueryValue($ids_only, null);
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_count_variants !== null) {
            $queryParams['maxCountVariants'] = ObjectSerializer::toQueryValue($max_count_variants, 'int32');
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($max_results_recommendations !== null) {
            $queryParams['maxResultsRecommendations'] = ObjectSerializer::toQueryValue($max_results_recommendations, 'int32');
        }
        // query params
        if ($max_results_similar_products !== null) {
            $queryParams['maxResultsSimilarProducts'] = ObjectSerializer::toQueryValue($max_results_similar_products, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($sid !== null) {
            $queryParams['sid'] = ObjectSerializer::toQueryValue($sid, null);
        }
        // query params
        if ($use_personalization !== null) {
            $queryParams['usePersonalization'] = ObjectSerializer::toQueryValue($use_personalization, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }
        // query params
        if ($with_campaigns !== null) {
            $queryParams['withCampaigns'] = ObjectSerializer::toQueryValue($with_campaigns, null);
        }
        // query params
        if ($with_recommendations !== null) {
            $queryParams['withRecommendations'] = ObjectSerializer::toQueryValue($with_recommendations, null);
        }
        // query params
        if ($with_record !== null) {
            $queryParams['withRecord'] = ObjectSerializer::toQueryValue($with_record, null);
        }
        // query params
        if ($with_similar_products !== null) {
            $queryParams['withSimilarProducts'] = ObjectSerializer::toQueryValue($with_similar_products, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFullRecordsUsingGET
     *
     * Get full records
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FullRecordsResult
     */
    public function getFullRecordsUsingGET($channel, $id, $id_type = 'id', $max_count_variants = '5', $purchaser_id = null)
    {
        list($response) = $this->getFullRecordsUsingGETWithHttpInfo($channel, $id, $id_type, $max_count_variants, $purchaser_id);
        return $response;
    }

    /**
     * Operation getFullRecordsUsingGETWithHttpInfo
     *
     * Get full records
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FullRecordsResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFullRecordsUsingGETWithHttpInfo($channel, $id, $id_type = 'id', $max_count_variants = '5', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\FullRecordsResult';
        $request = $this->getFullRecordsUsingGETRequest($channel, $id, $id_type, $max_count_variants, $purchaser_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FullRecordsResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFullRecordsUsingGETAsync
     *
     * Get full records
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullRecordsUsingGETAsync($channel, $id, $id_type = 'id', $max_count_variants = '5', $purchaser_id = null)
    {
        return $this->getFullRecordsUsingGETAsyncWithHttpInfo($channel, $id, $id_type, $max_count_variants, $purchaser_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFullRecordsUsingGETAsyncWithHttpInfo
     *
     * Get full records
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFullRecordsUsingGETAsyncWithHttpInfo($channel, $id, $id_type = 'id', $max_count_variants = '5', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\FullRecordsResult';
        $request = $this->getFullRecordsUsingGETRequest($channel, $id, $id_type, $max_count_variants, $purchaser_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFullRecordsUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional, default to 5)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFullRecordsUsingGETRequest($channel, $id, $id_type = 'id', $max_count_variants = '5', $purchaser_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getFullRecordsUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFullRecordsUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/full';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($max_count_variants !== null) {
            $queryParams['maxCountVariants'] = ObjectSerializer::toQueryValue($max_count_variants, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGeoUsingGET
     *
     * Get geo data
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which geo data should be returned. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GeoRecord[]
     */
    public function getGeoUsingGET($channel, $id)
    {
        list($response) = $this->getGeoUsingGETWithHttpInfo($channel, $id);
        return $response;
    }

    /**
     * Operation getGeoUsingGETWithHttpInfo
     *
     * Get geo data
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which geo data should be returned. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GeoRecord[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getGeoUsingGETWithHttpInfo($channel, $id)
    {
        $returnType = '\Swagger\Client\Model\GeoRecord[]';
        $request = $this->getGeoUsingGETRequest($channel, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GeoRecord[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGeoUsingGETAsync
     *
     * Get geo data
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which geo data should be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGeoUsingGETAsync($channel, $id)
    {
        return $this->getGeoUsingGETAsyncWithHttpInfo($channel, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGeoUsingGETAsyncWithHttpInfo
     *
     * Get geo data
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which geo data should be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGeoUsingGETAsyncWithHttpInfo($channel, $id)
    {
        $returnType = '\Swagger\Client\Model\GeoRecord[]';
        $request = $this->getGeoUsingGETRequest($channel, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGeoUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The product numbers of the records for which geo data should be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGeoUsingGETRequest($channel, $id)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getGeoUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getGeoUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/geo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMarketsUsingGET
     *
     * Get markets with location
     *
     * @param  string $channel channel (required)
     * @param  string[] $market_id The market ids. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MarketRecord[]
     */
    public function getMarketsUsingGET($channel, $market_id = null)
    {
        list($response) = $this->getMarketsUsingGETWithHttpInfo($channel, $market_id);
        return $response;
    }

    /**
     * Operation getMarketsUsingGETWithHttpInfo
     *
     * Get markets with location
     *
     * @param  string $channel channel (required)
     * @param  string[] $market_id The market ids. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MarketRecord[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getMarketsUsingGETWithHttpInfo($channel, $market_id = null)
    {
        $returnType = '\Swagger\Client\Model\MarketRecord[]';
        $request = $this->getMarketsUsingGETRequest($channel, $market_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MarketRecord[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMarketsUsingGETAsync
     *
     * Get markets with location
     *
     * @param  string $channel channel (required)
     * @param  string[] $market_id The market ids. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMarketsUsingGETAsync($channel, $market_id = null)
    {
        return $this->getMarketsUsingGETAsyncWithHttpInfo($channel, $market_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMarketsUsingGETAsyncWithHttpInfo
     *
     * Get markets with location
     *
     * @param  string $channel channel (required)
     * @param  string[] $market_id The market ids. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMarketsUsingGETAsyncWithHttpInfo($channel, $market_id = null)
    {
        $returnType = '\Swagger\Client\Model\MarketRecord[]';
        $request = $this->getMarketsUsingGETRequest($channel, $market_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMarketsUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $market_id The market ids. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMarketsUsingGETRequest($channel, $market_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getMarketsUsingGET'
            );
        }

        $resourcePath = '/rest/v5/markets/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecommendationUsingGET
     *
     * Get recommendations
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RecommendationResultWithFieldRoles
     */
    public function getRecommendationUsingGET($channel, $id, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '0', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null)
    {
        list($response) = $this->getRecommendationUsingGETWithHttpInfo($channel, $id, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $sid, $use_personalization, $user_id);
        return $response;
    }

    /**
     * Operation getRecommendationUsingGETWithHttpInfo
     *
     * Get recommendations
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RecommendationResultWithFieldRoles, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecommendationUsingGETWithHttpInfo($channel, $id, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '0', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\RecommendationResultWithFieldRoles';
        $request = $this->getRecommendationUsingGETRequest($channel, $id, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $sid, $use_personalization, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RecommendationResultWithFieldRoles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecommendationUsingGETAsync
     *
     * Get recommendations
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecommendationUsingGETAsync($channel, $id, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '0', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null)
    {
        return $this->getRecommendationUsingGETAsyncWithHttpInfo($channel, $id, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $sid, $use_personalization, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecommendationUsingGETAsyncWithHttpInfo
     *
     * Get recommendations
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecommendationUsingGETAsyncWithHttpInfo($channel, $id, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '0', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\RecommendationResultWithFieldRoles';
        $request = $this->getRecommendationUsingGETRequest($channel, $id, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $sid, $use_personalization, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecommendationUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param  bool $use_personalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecommendationUsingGETRequest($channel, $id, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '0', $purchaser_id = null, $sid = null, $use_personalization = 'true', $user_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getRecommendationUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecommendationUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/recommendation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, 'multi', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($ids_only !== null) {
            $queryParams['idsOnly'] = ObjectSerializer::toQueryValue($ids_only, null);
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($sid !== null) {
            $queryParams['sid'] = ObjectSerializer::toQueryValue($sid, null);
        }
        // query params
        if ($use_personalization !== null) {
            $queryParams['usePersonalization'] = ObjectSerializer::toQueryValue($use_personalization, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordMetaGetUsingGET
     *
     * Retrieve record metadata
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RecordMetaResult
     */
    public function getRecordMetaGetUsingGET($channel, $id, $id_type = 'id', $purchaser_id = null)
    {
        list($response) = $this->getRecordMetaGetUsingGETWithHttpInfo($channel, $id, $id_type, $purchaser_id);
        return $response;
    }

    /**
     * Operation getRecordMetaGetUsingGETWithHttpInfo
     *
     * Retrieve record metadata
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RecordMetaResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordMetaGetUsingGETWithHttpInfo($channel, $id, $id_type = 'id', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\RecordMetaResult';
        $request = $this->getRecordMetaGetUsingGETRequest($channel, $id, $id_type, $purchaser_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RecordMetaResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordMetaGetUsingGETAsync
     *
     * Retrieve record metadata
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordMetaGetUsingGETAsync($channel, $id, $id_type = 'id', $purchaser_id = null)
    {
        return $this->getRecordMetaGetUsingGETAsyncWithHttpInfo($channel, $id, $id_type, $purchaser_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordMetaGetUsingGETAsyncWithHttpInfo
     *
     * Retrieve record metadata
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordMetaGetUsingGETAsyncWithHttpInfo($channel, $id, $id_type = 'id', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\RecordMetaResult';
        $request = $this->getRecordMetaGetUsingGETRequest($channel, $id, $id_type, $purchaser_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordMetaGetUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $id The record ids of the records which should be returned (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecordMetaGetUsingGETRequest($channel, $id, $id_type = 'id', $purchaser_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getRecordMetaGetUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecordMetaGetUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($id)) {
            $id = ObjectSerializer::serializeCollection($id, 'multi', true);
        }
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordMetaPostUsingPOST
     *
     * Retrieve record metadata
     *
     * @param  \Swagger\Client\Model\MetaRequest $body metaRequest (required)
     * @param  string $channel channel (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RecordMetaResult
     */
    public function getRecordMetaPostUsingPOST($body, $channel, $id_type = 'id', $purchaser_id = null)
    {
        list($response) = $this->getRecordMetaPostUsingPOSTWithHttpInfo($body, $channel, $id_type, $purchaser_id);
        return $response;
    }

    /**
     * Operation getRecordMetaPostUsingPOSTWithHttpInfo
     *
     * Retrieve record metadata
     *
     * @param  \Swagger\Client\Model\MetaRequest $body metaRequest (required)
     * @param  string $channel channel (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RecordMetaResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordMetaPostUsingPOSTWithHttpInfo($body, $channel, $id_type = 'id', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\RecordMetaResult';
        $request = $this->getRecordMetaPostUsingPOSTRequest($body, $channel, $id_type, $purchaser_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RecordMetaResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordMetaPostUsingPOSTAsync
     *
     * Retrieve record metadata
     *
     * @param  \Swagger\Client\Model\MetaRequest $body metaRequest (required)
     * @param  string $channel channel (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordMetaPostUsingPOSTAsync($body, $channel, $id_type = 'id', $purchaser_id = null)
    {
        return $this->getRecordMetaPostUsingPOSTAsyncWithHttpInfo($body, $channel, $id_type, $purchaser_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordMetaPostUsingPOSTAsyncWithHttpInfo
     *
     * Retrieve record metadata
     *
     * @param  \Swagger\Client\Model\MetaRequest $body metaRequest (required)
     * @param  string $channel channel (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordMetaPostUsingPOSTAsyncWithHttpInfo($body, $channel, $id_type = 'id', $purchaser_id = null)
    {
        $returnType = '\Swagger\Client\Model\RecordMetaResult';
        $request = $this->getRecordMetaPostUsingPOSTRequest($body, $channel, $id_type, $purchaser_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordMetaPostUsingPOST'
     *
     * @param  \Swagger\Client\Model\MetaRequest $body metaRequest (required)
     * @param  string $channel channel (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (optional, default to id)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecordMetaPostUsingPOSTRequest($body, $channel, $id_type = 'id', $purchaser_id = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getRecordMetaPostUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getRecordMetaPostUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecordsUsingGET
     *
     * Get records
     *
     * @param  string $channel channel (required)
     * @param  string[] $product_number The product numbers of the records which should be returned. (required)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FlatRecordsResult
     */
    public function getRecordsUsingGET($channel, $product_number, $purchaser_id = null, $verbose = 'false')
    {
        list($response) = $this->getRecordsUsingGETWithHttpInfo($channel, $product_number, $purchaser_id, $verbose);
        return $response;
    }

    /**
     * Operation getRecordsUsingGETWithHttpInfo
     *
     * Get records
     *
     * @param  string $channel channel (required)
     * @param  string[] $product_number The product numbers of the records which should be returned. (required)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FlatRecordsResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecordsUsingGETWithHttpInfo($channel, $product_number, $purchaser_id = null, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\FlatRecordsResult';
        $request = $this->getRecordsUsingGETRequest($channel, $product_number, $purchaser_id, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FlatRecordsResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecordsUsingGETAsync
     *
     * Get records
     *
     * @param  string $channel channel (required)
     * @param  string[] $product_number The product numbers of the records which should be returned. (required)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsUsingGETAsync($channel, $product_number, $purchaser_id = null, $verbose = 'false')
    {
        return $this->getRecordsUsingGETAsyncWithHttpInfo($channel, $product_number, $purchaser_id, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecordsUsingGETAsyncWithHttpInfo
     *
     * Get records
     *
     * @param  string $channel channel (required)
     * @param  string[] $product_number The product numbers of the records which should be returned. (required)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecordsUsingGETAsyncWithHttpInfo($channel, $product_number, $purchaser_id = null, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\FlatRecordsResult';
        $request = $this->getRecordsUsingGETRequest($channel, $product_number, $purchaser_id, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecordsUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $product_number The product numbers of the records which should be returned. (required)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRecordsUsingGETRequest($channel, $product_number, $purchaser_id = null, $verbose = 'false')
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getRecordsUsingGET'
            );
        }
        // verify the required parameter 'product_number' is set
        if ($product_number === null || (is_array($product_number) && count($product_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_number when calling getRecordsUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($product_number)) {
            $product_number = ObjectSerializer::serializeCollection($product_number, 'multi', true);
        }
        if ($product_number !== null) {
            $queryParams['productNumber'] = ObjectSerializer::toQueryValue($product_number, null);
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSimilarProductsUsingGET
     *
     * Get similar products
     *
     * @param  string $channel channel (required)
     * @param  string $id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SimilarProductsWithFieldRoles
     */
    public function getSimilarProductsUsingGET($channel, $id, $id_type, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '10', $purchaser_id = null, $user_id = null)
    {
        list($response) = $this->getSimilarProductsUsingGETWithHttpInfo($channel, $id, $id_type, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $user_id);
        return $response;
    }

    /**
     * Operation getSimilarProductsUsingGETWithHttpInfo
     *
     * Get similar products
     *
     * @param  string $channel channel (required)
     * @param  string $id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SimilarProductsWithFieldRoles, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSimilarProductsUsingGETWithHttpInfo($channel, $id, $id_type, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '10', $purchaser_id = null, $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\SimilarProductsWithFieldRoles';
        $request = $this->getSimilarProductsUsingGETRequest($channel, $id, $id_type, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SimilarProductsWithFieldRoles',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSimilarProductsUsingGETAsync
     *
     * Get similar products
     *
     * @param  string $channel channel (required)
     * @param  string $id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarProductsUsingGETAsync($channel, $id, $id_type, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '10', $purchaser_id = null, $user_id = null)
    {
        return $this->getSimilarProductsUsingGETAsyncWithHttpInfo($channel, $id, $id_type, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSimilarProductsUsingGETAsyncWithHttpInfo
     *
     * Get similar products
     *
     * @param  string $channel channel (required)
     * @param  string $id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarProductsUsingGETAsyncWithHttpInfo($channel, $id, $id_type, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '10', $purchaser_id = null, $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\SimilarProductsWithFieldRoles';
        $request = $this->getSimilarProductsUsingGETRequest($channel, $id, $id_type, $exclude_products_not_in_range, $filter, $ids_only, $latitude, $longitude, $market_id, $max_distance, $max_results, $purchaser_id, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSimilarProductsUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string $id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param  string $id_type Use this parameter to determine the type of ID passed to the method. Use &#x27;productNumber&#x27; if the given ID is from the field with &#x27;productNumber&#x27; role. Use &#x27;id&#x27; if it is from the field with &#x27;masterId&#x27; role. (required)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filters for field values of recommended records. (optional)
     * @param  bool $ids_only If the value true is passed, then only the record IDs will be returned, streamlining the results. Additionally, if the Geo module is enabled, the IDs of all markets the product is mapped to will be also included. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the current location. (optional)
     * @param  double $longitude The longitude coordinate of the current location. (optional)
     * @param  string[] $market_id Currently selected markets (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $max_results Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $user_id This parameter is used to pass a user id for personalization across sessions. Required for Loop54 integrations. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSimilarProductsUsingGETRequest($channel, $id, $id_type, $exclude_products_not_in_range = null, $filter = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $max_results = '10', $purchaser_id = null, $user_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getSimilarProductsUsingGET'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSimilarProductsUsingGET'
            );
        }
        // verify the required parameter 'id_type' is set
        if ($id_type === null || (is_array($id_type) && count($id_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id_type when calling getSimilarProductsUsingGET'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/similar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, 'multi', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id, null);
        }
        // query params
        if ($id_type !== null) {
            $queryParams['idType'] = ObjectSerializer::toQueryValue($id_type, null);
        }
        // query params
        if ($ids_only !== null) {
            $queryParams['idsOnly'] = ObjectSerializer::toQueryValue($ids_only, null);
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertRecordsUsingPOST
     *
     * Insert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeltaUpdateResult[]
     */
    public function insertRecordsUsingPOST($body, $channel, $verbose = 'false')
    {
        list($response) = $this->insertRecordsUsingPOSTWithHttpInfo($body, $channel, $verbose);
        return $response;
    }

    /**
     * Operation insertRecordsUsingPOSTWithHttpInfo
     *
     * Insert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeltaUpdateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function insertRecordsUsingPOSTWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeltaUpdateResult[]';
        $request = $this->insertRecordsUsingPOSTRequest($body, $channel, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeltaUpdateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertRecordsUsingPOSTAsync
     *
     * Insert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertRecordsUsingPOSTAsync($body, $channel, $verbose = 'false')
    {
        return $this->insertRecordsUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertRecordsUsingPOSTAsyncWithHttpInfo
     *
     * Insert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertRecordsUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeltaUpdateResult[]';
        $request = $this->insertRecordsUsingPOSTRequest($body, $channel, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertRecordsUsingPOST'
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertRecordsUsingPOSTRequest($body, $channel, $verbose = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling insertRecordsUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling insertRecordsUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCustomerPricesUsingPOST
     *
     * Update customer prices
     *
     * @param  \Swagger\Client\Model\CustomerPriceRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CustomerPriceUpdateResult[]
     */
    public function updateCustomerPricesUsingPOST($body, $channel, $verbose = 'false')
    {
        list($response) = $this->updateCustomerPricesUsingPOSTWithHttpInfo($body, $channel, $verbose);
        return $response;
    }

    /**
     * Operation updateCustomerPricesUsingPOSTWithHttpInfo
     *
     * Update customer prices
     *
     * @param  \Swagger\Client\Model\CustomerPriceRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CustomerPriceUpdateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCustomerPricesUsingPOSTWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\CustomerPriceUpdateResult[]';
        $request = $this->updateCustomerPricesUsingPOSTRequest($body, $channel, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CustomerPriceUpdateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCustomerPricesUsingPOSTAsync
     *
     * Update customer prices
     *
     * @param  \Swagger\Client\Model\CustomerPriceRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomerPricesUsingPOSTAsync($body, $channel, $verbose = 'false')
    {
        return $this->updateCustomerPricesUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCustomerPricesUsingPOSTAsyncWithHttpInfo
     *
     * Update customer prices
     *
     * @param  \Swagger\Client\Model\CustomerPriceRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomerPricesUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\CustomerPriceUpdateResult[]';
        $request = $this->updateCustomerPricesUsingPOSTRequest($body, $channel, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCustomerPricesUsingPOST'
     *
     * @param  \Swagger\Client\Model\CustomerPriceRecord[] $body The records which should be inserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCustomerPricesUsingPOSTRequest($body, $channel, $verbose = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateCustomerPricesUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling updateCustomerPricesUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/customerprices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGeoUsingPOST
     *
     * Update geo data
     *
     * @param  \Swagger\Client\Model\GeoRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GeoUpdateResult[]
     */
    public function updateGeoUsingPOST($body, $channel, $verbose = 'false')
    {
        list($response) = $this->updateGeoUsingPOSTWithHttpInfo($body, $channel, $verbose);
        return $response;
    }

    /**
     * Operation updateGeoUsingPOSTWithHttpInfo
     *
     * Update geo data
     *
     * @param  \Swagger\Client\Model\GeoRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GeoUpdateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGeoUsingPOSTWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\GeoUpdateResult[]';
        $request = $this->updateGeoUsingPOSTRequest($body, $channel, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GeoUpdateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateGeoUsingPOSTAsync
     *
     * Update geo data
     *
     * @param  \Swagger\Client\Model\GeoRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGeoUsingPOSTAsync($body, $channel, $verbose = 'false')
    {
        return $this->updateGeoUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGeoUsingPOSTAsyncWithHttpInfo
     *
     * Update geo data
     *
     * @param  \Swagger\Client\Model\GeoRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGeoUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\GeoUpdateResult[]';
        $request = $this->updateGeoUsingPOSTRequest($body, $channel, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGeoUsingPOST'
     *
     * @param  \Swagger\Client\Model\GeoRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateGeoUsingPOSTRequest($body, $channel, $verbose = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateGeoUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling updateGeoUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/geo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMarketsUsingPOST
     *
     * Update markets
     *
     * @param  \Swagger\Client\Model\MarketRecord[] $body The markets which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MarketUpdateResult[]
     */
    public function updateMarketsUsingPOST($body, $channel, $verbose = 'false')
    {
        list($response) = $this->updateMarketsUsingPOSTWithHttpInfo($body, $channel, $verbose);
        return $response;
    }

    /**
     * Operation updateMarketsUsingPOSTWithHttpInfo
     *
     * Update markets
     *
     * @param  \Swagger\Client\Model\MarketRecord[] $body The markets which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MarketUpdateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMarketsUsingPOSTWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\MarketUpdateResult[]';
        $request = $this->updateMarketsUsingPOSTRequest($body, $channel, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MarketUpdateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateMarketsUsingPOSTAsync
     *
     * Update markets
     *
     * @param  \Swagger\Client\Model\MarketRecord[] $body The markets which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMarketsUsingPOSTAsync($body, $channel, $verbose = 'false')
    {
        return $this->updateMarketsUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMarketsUsingPOSTAsyncWithHttpInfo
     *
     * Update markets
     *
     * @param  \Swagger\Client\Model\MarketRecord[] $body The markets which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMarketsUsingPOSTAsyncWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\MarketUpdateResult[]';
        $request = $this->updateMarketsUsingPOSTRequest($body, $channel, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMarketsUsingPOST'
     *
     * @param  \Swagger\Client\Model\MarketRecord[] $body The markets which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateMarketsUsingPOSTRequest($body, $channel, $verbose = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateMarketsUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling updateMarketsUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/markets/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUsingPUT
     *
     * Update records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeltaUpdateResult[]
     */
    public function updateUsingPUT($body, $channel, $verbose = 'false')
    {
        list($response) = $this->updateUsingPUTWithHttpInfo($body, $channel, $verbose);
        return $response;
    }

    /**
     * Operation updateUsingPUTWithHttpInfo
     *
     * Update records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeltaUpdateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateUsingPUTWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeltaUpdateResult[]';
        $request = $this->updateUsingPUTRequest($body, $channel, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeltaUpdateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateUsingPUTAsync
     *
     * Update records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUsingPUTAsync($body, $channel, $verbose = 'false')
    {
        return $this->updateUsingPUTAsyncWithHttpInfo($body, $channel, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateUsingPUTAsyncWithHttpInfo
     *
     * Update records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateUsingPUTAsyncWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeltaUpdateResult[]';
        $request = $this->updateUsingPUTRequest($body, $channel, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateUsingPUT'
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be updated (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateUsingPUTRequest($body, $channel, $verbose = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateUsingPUT'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling updateUsingPUT'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation upsertRecordsUsingPUT
     *
     * Upsert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be upserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\DeltaUpdateResult[]
     */
    public function upsertRecordsUsingPUT($body, $channel, $verbose = 'false')
    {
        list($response) = $this->upsertRecordsUsingPUTWithHttpInfo($body, $channel, $verbose);
        return $response;
    }

    /**
     * Operation upsertRecordsUsingPUTWithHttpInfo
     *
     * Upsert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be upserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\DeltaUpdateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function upsertRecordsUsingPUTWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeltaUpdateResult[]';
        $request = $this->upsertRecordsUsingPUTRequest($body, $channel, $verbose);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\DeltaUpdateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation upsertRecordsUsingPUTAsync
     *
     * Upsert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be upserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function upsertRecordsUsingPUTAsync($body, $channel, $verbose = 'false')
    {
        return $this->upsertRecordsUsingPUTAsyncWithHttpInfo($body, $channel, $verbose)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation upsertRecordsUsingPUTAsyncWithHttpInfo
     *
     * Upsert records
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be upserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function upsertRecordsUsingPUTAsyncWithHttpInfo($body, $channel, $verbose = 'false')
    {
        $returnType = '\Swagger\Client\Model\DeltaUpdateResult[]';
        $request = $this->upsertRecordsUsingPUTRequest($body, $channel, $verbose);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'upsertRecordsUsingPUT'
     *
     * @param  \Swagger\Client\Model\FlatRecord[] $body The records which should be upserted (required)
     * @param  string $channel channel (required)
     * @param  bool $verbose verbose (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function upsertRecordsUsingPUTRequest($body, $channel, $verbose = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling upsertRecordsUsingPUT'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling upsertRecordsUsingPUT'
            );
        }

        $resourcePath = '/rest/v5/records/{channel}/upsert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($verbose !== null) {
            $queryParams['verbose'] = ObjectSerializer::toQueryValue($verbose, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
