<?php
/**
 * SearchApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FACT-Finder REST-API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v5
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.46
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\FactFinder;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * SearchApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SearchApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation categoryNavigationUsingGET
     *
     * Category ASN for Navigation
     *
     * @param  string $channel channel (required)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  int $end_level Category end level (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  int $start_level Category start level (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CategoryNavigation
     */
    public function categoryNavigationUsingGET($channel, $cache_irrelevant = null, $end_level = null, $exclude_products_not_in_range = null, $filter = null, $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $purchaser_id = null, $sid = null, $split_documents_at = null, $start_level = null, $substring_filter = null, $use_ab_test = 'true', $use_cache = 'true', $use_geo = 'true', $user_id = null)
    {
        list($response) = $this->categoryNavigationUsingGETWithHttpInfo($channel, $cache_irrelevant, $end_level, $exclude_products_not_in_range, $filter, $latitude, $longitude, $market_id, $max_distance, $purchaser_id, $sid, $split_documents_at, $start_level, $substring_filter, $use_ab_test, $use_cache, $use_geo, $user_id);
        return $response;
    }

    /**
     * Operation categoryNavigationUsingGETWithHttpInfo
     *
     * Category ASN for Navigation
     *
     * @param  string $channel channel (required)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  int $end_level Category end level (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  int $start_level Category start level (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CategoryNavigation, HTTP status code, HTTP response headers (array of strings)
     */
    public function categoryNavigationUsingGETWithHttpInfo($channel, $cache_irrelevant = null, $end_level = null, $exclude_products_not_in_range = null, $filter = null, $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $purchaser_id = null, $sid = null, $split_documents_at = null, $start_level = null, $substring_filter = null, $use_ab_test = 'true', $use_cache = 'true', $use_geo = 'true', $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\CategoryNavigation';
        $request = $this->categoryNavigationUsingGETRequest($channel, $cache_irrelevant, $end_level, $exclude_products_not_in_range, $filter, $latitude, $longitude, $market_id, $max_distance, $purchaser_id, $sid, $split_documents_at, $start_level, $substring_filter, $use_ab_test, $use_cache, $use_geo, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CategoryNavigation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation categoryNavigationUsingGETAsync
     *
     * Category ASN for Navigation
     *
     * @param  string $channel channel (required)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  int $end_level Category end level (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  int $start_level Category start level (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryNavigationUsingGETAsync($channel, $cache_irrelevant = null, $end_level = null, $exclude_products_not_in_range = null, $filter = null, $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $purchaser_id = null, $sid = null, $split_documents_at = null, $start_level = null, $substring_filter = null, $use_ab_test = 'true', $use_cache = 'true', $use_geo = 'true', $user_id = null)
    {
        return $this->categoryNavigationUsingGETAsyncWithHttpInfo($channel, $cache_irrelevant, $end_level, $exclude_products_not_in_range, $filter, $latitude, $longitude, $market_id, $max_distance, $purchaser_id, $sid, $split_documents_at, $start_level, $substring_filter, $use_ab_test, $use_cache, $use_geo, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation categoryNavigationUsingGETAsyncWithHttpInfo
     *
     * Category ASN for Navigation
     *
     * @param  string $channel channel (required)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  int $end_level Category end level (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  int $start_level Category start level (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function categoryNavigationUsingGETAsyncWithHttpInfo($channel, $cache_irrelevant = null, $end_level = null, $exclude_products_not_in_range = null, $filter = null, $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $purchaser_id = null, $sid = null, $split_documents_at = null, $start_level = null, $substring_filter = null, $use_ab_test = 'true', $use_cache = 'true', $use_geo = 'true', $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\CategoryNavigation';
        $request = $this->categoryNavigationUsingGETRequest($channel, $cache_irrelevant, $end_level, $exclude_products_not_in_range, $filter, $latitude, $longitude, $market_id, $max_distance, $purchaser_id, $sid, $split_documents_at, $start_level, $substring_filter, $use_ab_test, $use_cache, $use_geo, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'categoryNavigationUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  int $end_level Category end level (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  int $start_level Category start level (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function categoryNavigationUsingGETRequest($channel, $cache_irrelevant = null, $end_level = null, $exclude_products_not_in_range = null, $filter = null, $latitude = null, $longitude = null, $market_id = null, $max_distance = null, $purchaser_id = null, $sid = null, $split_documents_at = null, $start_level = null, $substring_filter = null, $use_ab_test = 'true', $use_cache = 'true', $use_geo = 'true', $user_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling categoryNavigationUsingGET'
            );
        }

        $resourcePath = '/rest/v5/navigation/category/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($cache_irrelevant)) {
            $cache_irrelevant = ObjectSerializer::serializeCollection($cache_irrelevant, 'multi', true);
        }
        if ($cache_irrelevant !== null) {
            $queryParams['cacheIrrelevant'] = ObjectSerializer::toQueryValue($cache_irrelevant, null);
        }
        // query params
        if ($end_level !== null) {
            $queryParams['endLevel'] = ObjectSerializer::toQueryValue($end_level, 'int32');
        }
        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, 'multi', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($sid !== null) {
            $queryParams['sid'] = ObjectSerializer::toQueryValue($sid, null);
        }
        // query params
        if ($split_documents_at !== null) {
            $queryParams['splitDocumentsAt'] = ObjectSerializer::toQueryValue($split_documents_at, 'int32');
        }
        // query params
        if ($start_level !== null) {
            $queryParams['startLevel'] = ObjectSerializer::toQueryValue($start_level, 'int32');
        }
        // query params
        if (is_array($substring_filter)) {
            $substring_filter = ObjectSerializer::serializeCollection($substring_filter, 'multi', true);
        }
        if ($substring_filter !== null) {
            $queryParams['substringFilter'] = ObjectSerializer::toQueryValue($substring_filter, null);
        }
        // query params
        if ($use_ab_test !== null) {
            $queryParams['useAbTest'] = ObjectSerializer::toQueryValue($use_ab_test, null);
        }
        // query params
        if ($use_cache !== null) {
            $queryParams['useCache'] = ObjectSerializer::toQueryValue($use_cache, null);
        }
        // query params
        if ($use_geo !== null) {
            $queryParams['useGeo'] = ObjectSerializer::toQueryValue($use_geo, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSuggestionsUsingGET
     *
     * Get suggestions
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid the session id from the user (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SuggestionResult
     */
    public function getSuggestionsUsingGET($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null)
    {
        list($response) = $this->getSuggestionsUsingGETWithHttpInfo($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $search_field, $sid, $sort, $split_documents_at, $substring_filter);
        return $response;
    }

    /**
     * Operation getSuggestionsUsingGETWithHttpInfo
     *
     * Get suggestions
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid the session id from the user (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SuggestionResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSuggestionsUsingGETWithHttpInfo($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null)
    {
        $returnType = '\Swagger\Client\Model\SuggestionResult';
        $request = $this->getSuggestionsUsingGETRequest($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $search_field, $sid, $sort, $split_documents_at, $substring_filter);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SuggestionResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSuggestionsUsingGETAsync
     *
     * Get suggestions
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid the session id from the user (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuggestionsUsingGETAsync($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null)
    {
        return $this->getSuggestionsUsingGETAsyncWithHttpInfo($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $search_field, $sid, $sort, $split_documents_at, $substring_filter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSuggestionsUsingGETAsyncWithHttpInfo
     *
     * Get suggestions
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid the session id from the user (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuggestionsUsingGETAsyncWithHttpInfo($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null)
    {
        $returnType = '\Swagger\Client\Model\SuggestionResult';
        $request = $this->getSuggestionsUsingGETRequest($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $search_field, $sid, $sort, $split_documents_at, $substring_filter);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSuggestionsUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid the session id from the user (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSuggestionsUsingGETRequest($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getSuggestionsUsingGET'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling getSuggestionsUsingGET'
            );
        }

        $resourcePath = '/rest/v5/suggest/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($advisor_status !== null) {
            $queryParams['advisorStatus'] = ObjectSerializer::toQueryValue($advisor_status, null);
        }
        // query params
        if ($article_number_search !== null) {
            $queryParams['articleNumberSearch'] = ObjectSerializer::toQueryValue($article_number_search, null);
        }
        // query params
        if (is_array($cache_irrelevant)) {
            $cache_irrelevant = ObjectSerializer::serializeCollection($cache_irrelevant, 'multi', true);
        }
        if ($cache_irrelevant !== null) {
            $queryParams['cacheIrrelevant'] = ObjectSerializer::toQueryValue($cache_irrelevant, null);
        }
        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, 'multi', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if ($follow_search !== null) {
            $queryParams['followSearch'] = ObjectSerializer::toQueryValue($follow_search, null);
        }
        // query params
        if ($hits_per_page !== null) {
            $queryParams['hitsPerPage'] = ObjectSerializer::toQueryValue($hits_per_page, 'int32');
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_count_variants !== null) {
            $queryParams['maxCountVariants'] = ObjectSerializer::toQueryValue($max_count_variants, 'int32');
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($search_field !== null) {
            $queryParams['searchField'] = ObjectSerializer::toQueryValue($search_field, null);
        }
        // query params
        if ($sid !== null) {
            $queryParams['sid'] = ObjectSerializer::toQueryValue($sid, null);
        }
        // query params
        if (is_array($sort)) {
            $sort = ObjectSerializer::serializeCollection($sort, 'multi', true);
        }
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($split_documents_at !== null) {
            $queryParams['splitDocumentsAt'] = ObjectSerializer::toQueryValue($split_documents_at, 'int32');
        }
        // query params
        if (is_array($substring_filter)) {
            $substring_filter = ObjectSerializer::serializeCollection($substring_filter, 'multi', true);
        }
        if ($substring_filter !== null) {
            $queryParams['substringFilter'] = ObjectSerializer::toQueryValue($substring_filter, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSuggestionsUsingPOST
     *
     * Get suggestions with POST
     *
     * @param  \Swagger\Client\Model\SuggestParams $body params (required)
     * @param  string $channel channel (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SuggestionResult
     */
    public function getSuggestionsUsingPOST($body, $channel)
    {
        list($response) = $this->getSuggestionsUsingPOSTWithHttpInfo($body, $channel);
        return $response;
    }

    /**
     * Operation getSuggestionsUsingPOSTWithHttpInfo
     *
     * Get suggestions with POST
     *
     * @param  \Swagger\Client\Model\SuggestParams $body params (required)
     * @param  string $channel channel (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SuggestionResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSuggestionsUsingPOSTWithHttpInfo($body, $channel)
    {
        $returnType = '\Swagger\Client\Model\SuggestionResult';
        $request = $this->getSuggestionsUsingPOSTRequest($body, $channel);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SuggestionResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSuggestionsUsingPOSTAsync
     *
     * Get suggestions with POST
     *
     * @param  \Swagger\Client\Model\SuggestParams $body params (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuggestionsUsingPOSTAsync($body, $channel)
    {
        return $this->getSuggestionsUsingPOSTAsyncWithHttpInfo($body, $channel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSuggestionsUsingPOSTAsyncWithHttpInfo
     *
     * Get suggestions with POST
     *
     * @param  \Swagger\Client\Model\SuggestParams $body params (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSuggestionsUsingPOSTAsyncWithHttpInfo($body, $channel)
    {
        $returnType = '\Swagger\Client\Model\SuggestionResult';
        $request = $this->getSuggestionsUsingPOSTRequest($body, $channel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSuggestionsUsingPOST'
     *
     * @param  \Swagger\Client\Model\SuggestParams $body params (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSuggestionsUsingPOSTRequest($body, $channel)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling getSuggestionsUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling getSuggestionsUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/suggest/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation navigationUsingGET
     *
     * Navigation
     *
     * @param  string $channel channel (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Result
     */
    public function navigationUsingGET($channel, $advisor_status = null, $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null)
    {
        list($response) = $this->navigationUsingGETWithHttpInfo($channel, $advisor_status, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id);
        return $response;
    }

    /**
     * Operation navigationUsingGETWithHttpInfo
     *
     * Navigation
     *
     * @param  string $channel channel (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function navigationUsingGETWithHttpInfo($channel, $advisor_status = null, $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->navigationUsingGETRequest($channel, $advisor_status, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation navigationUsingGETAsync
     *
     * Navigation
     *
     * @param  string $channel channel (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function navigationUsingGETAsync($channel, $advisor_status = null, $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null)
    {
        return $this->navigationUsingGETAsyncWithHttpInfo($channel, $advisor_status, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation navigationUsingGETAsyncWithHttpInfo
     *
     * Navigation
     *
     * @param  string $channel channel (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function navigationUsingGETAsyncWithHttpInfo($channel, $advisor_status = null, $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->navigationUsingGETRequest($channel, $advisor_status, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'navigationUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function navigationUsingGETRequest($channel, $advisor_status = null, $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling navigationUsingGET'
            );
        }

        $resourcePath = '/rest/v5/navigation/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($advisor_status !== null) {
            $queryParams['advisorStatus'] = ObjectSerializer::toQueryValue($advisor_status, null);
        }
        // query params
        if (is_array($cache_irrelevant)) {
            $cache_irrelevant = ObjectSerializer::serializeCollection($cache_irrelevant, 'multi', true);
        }
        if ($cache_irrelevant !== null) {
            $queryParams['cacheIrrelevant'] = ObjectSerializer::toQueryValue($cache_irrelevant, null);
        }
        // query params
        if ($deduplication_field !== null) {
            $queryParams['deduplicationField'] = ObjectSerializer::toQueryValue($deduplication_field, null);
        }
        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, 'multi', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if ($follow_search !== null) {
            $queryParams['followSearch'] = ObjectSerializer::toQueryValue($follow_search, null);
        }
        // query params
        if ($hits_per_page !== null) {
            $queryParams['hitsPerPage'] = ObjectSerializer::toQueryValue($hits_per_page, 'int32');
        }
        // query params
        if ($ids_only !== null) {
            $queryParams['idsOnly'] = ObjectSerializer::toQueryValue($ids_only, null);
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_count_variants !== null) {
            $queryParams['maxCountVariants'] = ObjectSerializer::toQueryValue($max_count_variants, 'int32');
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($sid !== null) {
            $queryParams['sid'] = ObjectSerializer::toQueryValue($sid, null);
        }
        // query params
        if (is_array($sort)) {
            $sort = ObjectSerializer::serializeCollection($sort, 'multi', true);
        }
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($split_documents_at !== null) {
            $queryParams['splitDocumentsAt'] = ObjectSerializer::toQueryValue($split_documents_at, 'int32');
        }
        // query params
        if (is_array($substring_filter)) {
            $substring_filter = ObjectSerializer::serializeCollection($substring_filter, 'multi', true);
        }
        if ($substring_filter !== null) {
            $queryParams['substringFilter'] = ObjectSerializer::toQueryValue($substring_filter, null);
        }
        // query params
        if ($use_ab_test !== null) {
            $queryParams['useAbTest'] = ObjectSerializer::toQueryValue($use_ab_test, null);
        }
        // query params
        if ($use_asn !== null) {
            $queryParams['useAsn'] = ObjectSerializer::toQueryValue($use_asn, null);
        }
        // query params
        if ($use_aso !== null) {
            $queryParams['useAso'] = ObjectSerializer::toQueryValue($use_aso, null);
        }
        // query params
        if ($use_cache !== null) {
            $queryParams['useCache'] = ObjectSerializer::toQueryValue($use_cache, null);
        }
        // query params
        if ($use_campaigns !== null) {
            $queryParams['useCampaigns'] = ObjectSerializer::toQueryValue($use_campaigns, null);
        }
        // query params
        if ($use_deduplication !== null) {
            $queryParams['useDeduplication'] = ObjectSerializer::toQueryValue($use_deduplication, null);
        }
        // query params
        if ($use_found_words !== null) {
            $queryParams['useFoundWords'] = ObjectSerializer::toQueryValue($use_found_words, null);
        }
        // query params
        if ($use_geo !== null) {
            $queryParams['useGeo'] = ObjectSerializer::toQueryValue($use_geo, null);
        }
        // query params
        if ($use_personalization !== null) {
            $queryParams['usePersonalization'] = ObjectSerializer::toQueryValue($use_personalization, null);
        }
        // query params
        if ($use_ranking !== null) {
            $queryParams['useRanking'] = ObjectSerializer::toQueryValue($use_ranking, null);
        }
        // query params
        if ($use_search !== null) {
            $queryParams['useSearch'] = ObjectSerializer::toQueryValue($use_search, null);
        }
        // query params
        if ($use_semantic_enhancer !== null) {
            $queryParams['useSemanticEnhancer'] = ObjectSerializer::toQueryValue($use_semantic_enhancer, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation navigationUsingPOST
     *
     * Navigation with POST
     *
     * @param  \Swagger\Client\Model\NavigationRequest $body navigationRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Result
     */
    public function navigationUsingPOST($body, $channel)
    {
        list($response) = $this->navigationUsingPOSTWithHttpInfo($body, $channel);
        return $response;
    }

    /**
     * Operation navigationUsingPOSTWithHttpInfo
     *
     * Navigation with POST
     *
     * @param  \Swagger\Client\Model\NavigationRequest $body navigationRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function navigationUsingPOSTWithHttpInfo($body, $channel)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->navigationUsingPOSTRequest($body, $channel);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation navigationUsingPOSTAsync
     *
     * Navigation with POST
     *
     * @param  \Swagger\Client\Model\NavigationRequest $body navigationRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function navigationUsingPOSTAsync($body, $channel)
    {
        return $this->navigationUsingPOSTAsyncWithHttpInfo($body, $channel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation navigationUsingPOSTAsyncWithHttpInfo
     *
     * Navigation with POST
     *
     * @param  \Swagger\Client\Model\NavigationRequest $body navigationRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function navigationUsingPOSTAsyncWithHttpInfo($body, $channel)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->navigationUsingPOSTRequest($body, $channel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'navigationUsingPOST'
     *
     * @param  \Swagger\Client\Model\NavigationRequest $body navigationRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function navigationUsingPOSTRequest($body, $channel)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling navigationUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling navigationUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/navigation/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchUsingGET
     *
     * Search
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $query_from_suggest This parameter indicates that the FACT-Finder query was triggered through a selection from the suggestion list. In this case send the parameter with the value true. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     * @param  string $user_input Use this parameter to send the characters, the shop user entered until the search query was triggered. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Result
     */
    public function searchUsingGET($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $query_from_suggest = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null, $user_input = null)
    {
        list($response) = $this->searchUsingGETWithHttpInfo($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $query_from_suggest, $search_field, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id, $user_input);
        return $response;
    }

    /**
     * Operation searchUsingGETWithHttpInfo
     *
     * Search
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $query_from_suggest This parameter indicates that the FACT-Finder query was triggered through a selection from the suggestion list. In this case send the parameter with the value true. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     * @param  string $user_input Use this parameter to send the characters, the shop user entered until the search query was triggered. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchUsingGETWithHttpInfo($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $query_from_suggest = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null, $user_input = null)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->searchUsingGETRequest($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $query_from_suggest, $search_field, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id, $user_input);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchUsingGETAsync
     *
     * Search
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $query_from_suggest This parameter indicates that the FACT-Finder query was triggered through a selection from the suggestion list. In this case send the parameter with the value true. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     * @param  string $user_input Use this parameter to send the characters, the shop user entered until the search query was triggered. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUsingGETAsync($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $query_from_suggest = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null, $user_input = null)
    {
        return $this->searchUsingGETAsyncWithHttpInfo($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $query_from_suggest, $search_field, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id, $user_input)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchUsingGETAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $query_from_suggest This parameter indicates that the FACT-Finder query was triggered through a selection from the suggestion list. In this case send the parameter with the value true. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     * @param  string $user_input Use this parameter to send the characters, the shop user entered until the search query was triggered. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUsingGETAsyncWithHttpInfo($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $query_from_suggest = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null, $user_input = null)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->searchUsingGETRequest($channel, $query, $advisor_status, $article_number_search, $cache_irrelevant, $deduplication_field, $exclude_products_not_in_range, $filter, $follow_search, $hits_per_page, $ids_only, $latitude, $longitude, $market_id, $max_count_variants, $max_distance, $page, $purchaser_id, $query_from_suggest, $search_field, $sid, $sort, $split_documents_at, $substring_filter, $use_ab_test, $use_asn, $use_aso, $use_cache, $use_campaigns, $use_deduplication, $use_found_words, $use_geo, $use_personalization, $use_ranking, $use_search, $use_semantic_enhancer, $user_id, $user_input);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchUsingGET'
     *
     * @param  string $channel channel (required)
     * @param  string $query The search term (required)
     * @param  string $advisor_status For specifying the current campaign id and answer path; format: campaignId-answerPath; example &#x3D; &#x27;4-_0_1&#x27; (optional)
     * @param  string $article_number_search Specifies if the query should be interpreted as article number (optional, default to DETECT)
     * @param  string[] $cache_irrelevant Flag parameters as cache irrelevant (optional)
     * @param  string $deduplication_field Specifies on which field variants should be deduplicated. (optional)
     * @param  bool $exclude_products_not_in_range Use this parameter to override the geo setting \&quot;exclude products not in range\&quot; for this request. (optional)
     * @param  string[] $filter Filter for the whole field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  string $follow_search Optional request linking param from a previous search result or search param object. Can improve request performance. (optional)
     * @param  int $hits_per_page In the FACT-Finder Management Interface you can define how many results will be returned on a page by default. If you prefer another number, you can set it with this parameter. (optional)
     * @param  bool $ids_only If true, the returned records will contain only record IDs. (optional, default to false)
     * @param  double $latitude The latitude coordinate of the location. (optional)
     * @param  double $longitude The longitude coordinate of the location. (optional)
     * @param  string[] $market_id Only show products that have values for these market IDs. (optional)
     * @param  int $max_count_variants The maximum number of variants to return for every record (optional)
     * @param  double $max_distance Use this parameter to override the geo setting \&quot;maximum distance\&quot; for this request. (optional)
     * @param  int $page If a search result contains many results these will be divided into pages. This limits the amount of data that has to be sent in one go. You can indicate which page should be returned. Page numbering starts at 1. (optional)
     * @param  string $purchaser_id Use this parameter to pass the purchaser ID. This ID is only needed, if the &#x27;customer specific pricing&#x27; module is active. Otherwise it will be ignored. (optional)
     * @param  bool $query_from_suggest This parameter indicates that the FACT-Finder query was triggered through a selection from the suggestion list. In this case send the parameter with the value true. (optional)
     * @param  string $search_field Normally FACT-Finder searches all fields defined as searchable. However it is possible to search only one specific field as well. (optional)
     * @param  string $sid The session id (optional)
     * @param  string[] $sort Sort the result; use FieldName Relevancy to sort the relevancy; format: FieldName:order order must be either asc or desc; example Manufacturer:asc (optional)
     * @param  int $split_documents_at Threshold for variant splitting of documents. (optional)
     * @param  string[] $substring_filter Filter for a sub string of the field value; a filter can have multiple values, the values can be separated with the following characters (they are configurable in the config.xml) &#x27;and&#x27; &#x3D; \\_\\_\\_ &#x27;or&#x27; &#x3D; ~~~ the filter value can be excluded with the prefix ! format: facetid:value; example Red~~~!Green &#x3D; red or not green. If the filter name equals &#x27;*&#x27;, the filter will be applied on any field; example: *:Red~~~Green. This filter type does not support the exclusion prefix. Be aware that filter values for category path filters have to be URL encoded, so a &#x27;100%&#x27; category path filter value would be &#x27;100%25&#x27;. It will be encoded a second time when used via &#x27;GET&#x27;, Swagger will do this second encoding automatically, so the URL contains &#x27;100%2525&#x27;. Numeric filters use standard mathematical interval notation, but only intervals that are closed on the left and open on the right are allowed inputs. So only intervals of the form [a,b), [a,) or [a,] are allowed. Square brackets mean that the value is included and round brackets mean that the value is not included. E.g. if you want to cover the range 20.00-49.99 please insert [20.00,50.00). (optional)
     * @param  bool $use_ab_test If true AbTest features will be active. (optional, default to true)
     * @param  bool $use_asn If true, filters should be generated for the result. (optional, default to true)
     * @param  bool $use_aso If true, automatic search optimization will be used. (optional, default to true)
     * @param  bool $use_cache If true, the search result will be returned from cache memory, if a possible matching result exists. (optional, default to true)
     * @param  bool $use_campaigns If true, campaigns corresponding to this search result will be returned. (optional, default to true)
     * @param  bool $use_deduplication If true, the configured deduplication of variants will be used. (optional, default to true)
     * @param  bool $use_found_words If true, the words that led to the records in the search results will be determined; this may require a large amount of processing time. (optional, default to false)
     * @param  bool $use_geo If true geoSearch features will be active. (optional, default to true)
     * @param  bool $use_personalization If true, the relevant products in the result will be personalized. (optional, default to true)
     * @param  bool $use_ranking If true, ranking will be applied. (optional, default to true)
     * @param  bool $use_search If true, search will be executed for the query. (optional, default to true)
     * @param  bool $use_semantic_enhancer If true, the semantic enhancer will be used. (optional, default to true)
     * @param  string $user_id The user id (optional)
     * @param  string $user_input Use this parameter to send the characters, the shop user entered until the search query was triggered. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchUsingGETRequest($channel, $query, $advisor_status = null, $article_number_search = 'DETECT', $cache_irrelevant = null, $deduplication_field = null, $exclude_products_not_in_range = null, $filter = null, $follow_search = null, $hits_per_page = null, $ids_only = 'false', $latitude = null, $longitude = null, $market_id = null, $max_count_variants = null, $max_distance = null, $page = null, $purchaser_id = null, $query_from_suggest = null, $search_field = null, $sid = null, $sort = null, $split_documents_at = null, $substring_filter = null, $use_ab_test = 'true', $use_asn = 'true', $use_aso = 'true', $use_cache = 'true', $use_campaigns = 'true', $use_deduplication = 'true', $use_found_words = 'false', $use_geo = 'true', $use_personalization = 'true', $use_ranking = 'true', $use_search = 'true', $use_semantic_enhancer = 'true', $user_id = null, $user_input = null)
    {
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling searchUsingGET'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchUsingGET'
            );
        }

        $resourcePath = '/rest/v5/search/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($advisor_status !== null) {
            $queryParams['advisorStatus'] = ObjectSerializer::toQueryValue($advisor_status, null);
        }
        // query params
        if ($article_number_search !== null) {
            $queryParams['articleNumberSearch'] = ObjectSerializer::toQueryValue($article_number_search, null);
        }
        // query params
        if (is_array($cache_irrelevant)) {
            $cache_irrelevant = ObjectSerializer::serializeCollection($cache_irrelevant, 'multi', true);
        }
        if ($cache_irrelevant !== null) {
            $queryParams['cacheIrrelevant'] = ObjectSerializer::toQueryValue($cache_irrelevant, null);
        }
        // query params
        if ($deduplication_field !== null) {
            $queryParams['deduplicationField'] = ObjectSerializer::toQueryValue($deduplication_field, null);
        }
        // query params
        if ($exclude_products_not_in_range !== null) {
            $queryParams['excludeProductsNotInRange'] = ObjectSerializer::toQueryValue($exclude_products_not_in_range, null);
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, 'multi', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter, null);
        }
        // query params
        if ($follow_search !== null) {
            $queryParams['followSearch'] = ObjectSerializer::toQueryValue($follow_search, null);
        }
        // query params
        if ($hits_per_page !== null) {
            $queryParams['hitsPerPage'] = ObjectSerializer::toQueryValue($hits_per_page, 'int32');
        }
        // query params
        if ($ids_only !== null) {
            $queryParams['idsOnly'] = ObjectSerializer::toQueryValue($ids_only, null);
        }
        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, 'double');
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, 'double');
        }
        // query params
        if (is_array($market_id)) {
            $market_id = ObjectSerializer::serializeCollection($market_id, 'multi', true);
        }
        if ($market_id !== null) {
            $queryParams['marketId'] = ObjectSerializer::toQueryValue($market_id, null);
        }
        // query params
        if ($max_count_variants !== null) {
            $queryParams['maxCountVariants'] = ObjectSerializer::toQueryValue($max_count_variants, 'int32');
        }
        // query params
        if ($max_distance !== null) {
            $queryParams['maxDistance'] = ObjectSerializer::toQueryValue($max_distance, 'double');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($purchaser_id !== null) {
            $queryParams['purchaserId'] = ObjectSerializer::toQueryValue($purchaser_id, null);
        }
        // query params
        if ($query !== null) {
            $queryParams['query'] = ObjectSerializer::toQueryValue($query, null);
        }
        // query params
        if ($query_from_suggest !== null) {
            $queryParams['queryFromSuggest'] = ObjectSerializer::toQueryValue($query_from_suggest, null);
        }
        // query params
        if ($search_field !== null) {
            $queryParams['searchField'] = ObjectSerializer::toQueryValue($search_field, null);
        }
        // query params
        if ($sid !== null) {
            $queryParams['sid'] = ObjectSerializer::toQueryValue($sid, null);
        }
        // query params
        if (is_array($sort)) {
            $sort = ObjectSerializer::serializeCollection($sort, 'multi', true);
        }
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort, null);
        }
        // query params
        if ($split_documents_at !== null) {
            $queryParams['splitDocumentsAt'] = ObjectSerializer::toQueryValue($split_documents_at, 'int32');
        }
        // query params
        if (is_array($substring_filter)) {
            $substring_filter = ObjectSerializer::serializeCollection($substring_filter, 'multi', true);
        }
        if ($substring_filter !== null) {
            $queryParams['substringFilter'] = ObjectSerializer::toQueryValue($substring_filter, null);
        }
        // query params
        if ($use_ab_test !== null) {
            $queryParams['useAbTest'] = ObjectSerializer::toQueryValue($use_ab_test, null);
        }
        // query params
        if ($use_asn !== null) {
            $queryParams['useAsn'] = ObjectSerializer::toQueryValue($use_asn, null);
        }
        // query params
        if ($use_aso !== null) {
            $queryParams['useAso'] = ObjectSerializer::toQueryValue($use_aso, null);
        }
        // query params
        if ($use_cache !== null) {
            $queryParams['useCache'] = ObjectSerializer::toQueryValue($use_cache, null);
        }
        // query params
        if ($use_campaigns !== null) {
            $queryParams['useCampaigns'] = ObjectSerializer::toQueryValue($use_campaigns, null);
        }
        // query params
        if ($use_deduplication !== null) {
            $queryParams['useDeduplication'] = ObjectSerializer::toQueryValue($use_deduplication, null);
        }
        // query params
        if ($use_found_words !== null) {
            $queryParams['useFoundWords'] = ObjectSerializer::toQueryValue($use_found_words, null);
        }
        // query params
        if ($use_geo !== null) {
            $queryParams['useGeo'] = ObjectSerializer::toQueryValue($use_geo, null);
        }
        // query params
        if ($use_personalization !== null) {
            $queryParams['usePersonalization'] = ObjectSerializer::toQueryValue($use_personalization, null);
        }
        // query params
        if ($use_ranking !== null) {
            $queryParams['useRanking'] = ObjectSerializer::toQueryValue($use_ranking, null);
        }
        // query params
        if ($use_search !== null) {
            $queryParams['useSearch'] = ObjectSerializer::toQueryValue($use_search, null);
        }
        // query params
        if ($use_semantic_enhancer !== null) {
            $queryParams['useSemanticEnhancer'] = ObjectSerializer::toQueryValue($use_semantic_enhancer, null);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['userId'] = ObjectSerializer::toQueryValue($user_id, null);
        }
        // query params
        if ($user_input !== null) {
            $queryParams['userInput'] = ObjectSerializer::toQueryValue($user_input, null);
        }

        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchUsingPOST
     *
     * Search with POST
     *
     * @param  \Swagger\Client\Model\SearchRequest $body searchRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Result
     */
    public function searchUsingPOST($body, $channel)
    {
        list($response) = $this->searchUsingPOSTWithHttpInfo($body, $channel);
        return $response;
    }

    /**
     * Operation searchUsingPOSTWithHttpInfo
     *
     * Search with POST
     *
     * @param  \Swagger\Client\Model\SearchRequest $body searchRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Result, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchUsingPOSTWithHttpInfo($body, $channel)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->searchUsingPOSTRequest($body, $channel);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Result',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ApiError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchUsingPOSTAsync
     *
     * Search with POST
     *
     * @param  \Swagger\Client\Model\SearchRequest $body searchRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUsingPOSTAsync($body, $channel)
    {
        return $this->searchUsingPOSTAsyncWithHttpInfo($body, $channel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchUsingPOSTAsyncWithHttpInfo
     *
     * Search with POST
     *
     * @param  \Swagger\Client\Model\SearchRequest $body searchRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUsingPOSTAsyncWithHttpInfo($body, $channel)
    {
        $returnType = '\Swagger\Client\Model\Result';
        $request = $this->searchUsingPOSTRequest($body, $channel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchUsingPOST'
     *
     * @param  \Swagger\Client\Model\SearchRequest $body searchRequest (required)
     * @param  string $channel channel (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchUsingPOSTRequest($body, $channel)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling searchUsingPOST'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling searchUsingPOST'
            );
        }

        $resourcePath = '/rest/v5/search/{channel}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel !== null) {
            $resourcePath = str_replace(
                '{' . 'channel' . '}',
                ObjectSerializer::toPathValue($channel),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
