<?php
/**
 * FacetElement
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FACT-Finder REST-API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v5
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.46
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * FacetElement Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FacetElement implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'FacetElement';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'absolute_max_value' => 'double',
        'absolute_min_value' => 'double',
        'cluster_level' => 'int',
        'distance' => 'double',
        'preview_image_url' => 'string',
        'search_params' => '\Swagger\Client\Model\SearchParams',
        'selected' => 'string',
        'selected_max_value' => 'double',
        'selected_min_value' => 'double',
        'show_distance' => 'bool',
        'text' => 'string',
        'total_hits' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'absolute_max_value' => 'double',
        'absolute_min_value' => 'double',
        'cluster_level' => 'int32',
        'distance' => 'double',
        'preview_image_url' => null,
        'search_params' => null,
        'selected' => null,
        'selected_max_value' => 'double',
        'selected_min_value' => 'double',
        'show_distance' => null,
        'text' => null,
        'total_hits' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'absolute_max_value' => 'absoluteMaxValue',
        'absolute_min_value' => 'absoluteMinValue',
        'cluster_level' => 'clusterLevel',
        'distance' => 'distance',
        'preview_image_url' => 'previewImageURL',
        'search_params' => 'searchParams',
        'selected' => 'selected',
        'selected_max_value' => 'selectedMaxValue',
        'selected_min_value' => 'selectedMinValue',
        'show_distance' => 'showDistance',
        'text' => 'text',
        'total_hits' => 'totalHits'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'absolute_max_value' => 'setAbsoluteMaxValue',
        'absolute_min_value' => 'setAbsoluteMinValue',
        'cluster_level' => 'setClusterLevel',
        'distance' => 'setDistance',
        'preview_image_url' => 'setPreviewImageUrl',
        'search_params' => 'setSearchParams',
        'selected' => 'setSelected',
        'selected_max_value' => 'setSelectedMaxValue',
        'selected_min_value' => 'setSelectedMinValue',
        'show_distance' => 'setShowDistance',
        'text' => 'setText',
        'total_hits' => 'setTotalHits'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'absolute_max_value' => 'getAbsoluteMaxValue',
        'absolute_min_value' => 'getAbsoluteMinValue',
        'cluster_level' => 'getClusterLevel',
        'distance' => 'getDistance',
        'preview_image_url' => 'getPreviewImageUrl',
        'search_params' => 'getSearchParams',
        'selected' => 'getSelected',
        'selected_max_value' => 'getSelectedMaxValue',
        'selected_min_value' => 'getSelectedMinValue',
        'show_distance' => 'getShowDistance',
        'text' => 'getText',
        'total_hits' => 'getTotalHits'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const SELECTED_TRUE = 'TRUE';
    const SELECTED_FALSE = 'FALSE';
    const SELECTED_IMPLICIT = 'IMPLICIT';
    const SELECTED_IRRELEVANT = 'IRRELEVANT';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSelectedAllowableValues()
    {
        return [
            self::SELECTED_TRUE,
            self::SELECTED_FALSE,
            self::SELECTED_IMPLICIT,
            self::SELECTED_IRRELEVANT,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['absolute_max_value'] = isset($data['absolute_max_value']) ? $data['absolute_max_value'] : null;
        $this->container['absolute_min_value'] = isset($data['absolute_min_value']) ? $data['absolute_min_value'] : null;
        $this->container['cluster_level'] = isset($data['cluster_level']) ? $data['cluster_level'] : null;
        $this->container['distance'] = isset($data['distance']) ? $data['distance'] : null;
        $this->container['preview_image_url'] = isset($data['preview_image_url']) ? $data['preview_image_url'] : null;
        $this->container['search_params'] = isset($data['search_params']) ? $data['search_params'] : null;
        $this->container['selected'] = isset($data['selected']) ? $data['selected'] : null;
        $this->container['selected_max_value'] = isset($data['selected_max_value']) ? $data['selected_max_value'] : null;
        $this->container['selected_min_value'] = isset($data['selected_min_value']) ? $data['selected_min_value'] : null;
        $this->container['show_distance'] = isset($data['show_distance']) ? $data['show_distance'] : null;
        $this->container['text'] = isset($data['text']) ? $data['text'] : null;
        $this->container['total_hits'] = isset($data['total_hits']) ? $data['total_hits'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['cluster_level'] === null) {
            $invalidProperties[] = "'cluster_level' can't be null";
        }
        if ($this->container['selected'] === null) {
            $invalidProperties[] = "'selected' can't be null";
        }
        $allowedValues = $this->getSelectedAllowableValues();
        if (!is_null($this->container['selected']) && !in_array($this->container['selected'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'selected', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets absolute_max_value
     *
     * @return double
     */
    public function getAbsoluteMaxValue()
    {
        return $this->container['absolute_max_value'];
    }

    /**
     * Sets absolute_max_value
     *
     * @param double $absolute_max_value The absolute maximum value for the overall slider range.
     *
     * @return $this
     */
    public function setAbsoluteMaxValue($absolute_max_value)
    {
        $this->container['absolute_max_value'] = $absolute_max_value;

        return $this;
    }

    /**
     * Gets absolute_min_value
     *
     * @return double
     */
    public function getAbsoluteMinValue()
    {
        return $this->container['absolute_min_value'];
    }

    /**
     * Sets absolute_min_value
     *
     * @param double $absolute_min_value The absolute minimum value for the overall slider range.
     *
     * @return $this
     */
    public function setAbsoluteMinValue($absolute_min_value)
    {
        $this->container['absolute_min_value'] = $absolute_min_value;

        return $this;
    }

    /**
     * Gets cluster_level
     *
     * @return int
     */
    public function getClusterLevel()
    {
        return $this->container['cluster_level'];
    }

    /**
     * Sets cluster_level
     *
     * @param int $cluster_level Level in the cluster hierarchy. Corresponding subcategories have a higher (deeper) level.
     *
     * @return $this
     */
    public function setClusterLevel($cluster_level)
    {
        $this->container['cluster_level'] = $cluster_level;

        return $this;
    }

    /**
     * Gets distance
     *
     * @return double
     */
    public function getDistance()
    {
        return $this->container['distance'];
    }

    /**
     * Sets distance
     *
     * @param double $distance The distance between the location of the search and the market location associated with this element.
     *
     * @return $this
     */
    public function setDistance($distance)
    {
        $this->container['distance'] = $distance;

        return $this;
    }

    /**
     * Gets preview_image_url
     *
     * @return string
     */
    public function getPreviewImageUrl()
    {
        return $this->container['preview_image_url'];
    }

    /**
     * Sets preview_image_url
     *
     * @param string $preview_image_url URL to the preview image to be displayed with the element.
     *
     * @return $this
     */
    public function setPreviewImageUrl($preview_image_url)
    {
        $this->container['preview_image_url'] = $preview_image_url;

        return $this;
    }

    /**
     * Gets search_params
     *
     * @return \Swagger\Client\Model\SearchParams
     */
    public function getSearchParams()
    {
        return $this->container['search_params'];
    }

    /**
     * Sets search_params
     *
     * @param \Swagger\Client\Model\SearchParams $search_params search_params
     *
     * @return $this
     */
    public function setSearchParams($search_params)
    {
        $this->container['search_params'] = $search_params;

        return $this;
    }

    /**
     * Gets selected
     *
     * @return string
     */
    public function getSelected()
    {
        return $this->container['selected'];
    }

    /**
     * Sets selected
     *
     * @param string $selected TRUE, if the element is currently selected, IMPLICIT, if the selection is implicit, IRRELEVANT means, that the element has been selected by the user, but does not match any record of the search result, otherwise FALSE.
     *
     * @return $this
     */
    public function setSelected($selected)
    {
        $allowedValues = $this->getSelectedAllowableValues();
        if (!in_array($selected, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'selected', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['selected'] = $selected;

        return $this;
    }

    /**
     * Gets selected_max_value
     *
     * @return double
     */
    public function getSelectedMaxValue()
    {
        return $this->container['selected_max_value'];
    }

    /**
     * Sets selected_max_value
     *
     * @param double $selected_max_value The maximum value of the currently selected slider range.
     *
     * @return $this
     */
    public function setSelectedMaxValue($selected_max_value)
    {
        $this->container['selected_max_value'] = $selected_max_value;

        return $this;
    }

    /**
     * Gets selected_min_value
     *
     * @return double
     */
    public function getSelectedMinValue()
    {
        return $this->container['selected_min_value'];
    }

    /**
     * Sets selected_min_value
     *
     * @param double $selected_min_value The minimum value of the currently selected slider range.
     *
     * @return $this
     */
    public function setSelectedMinValue($selected_min_value)
    {
        $this->container['selected_min_value'] = $selected_min_value;

        return $this;
    }

    /**
     * Gets show_distance
     *
     * @return bool
     */
    public function getShowDistance()
    {
        return $this->container['show_distance'];
    }

    /**
     * Sets show_distance
     *
     * @param bool $show_distance If 'true', the distance should be added to the element name label by frontend.
     *
     * @return $this
     */
    public function setShowDistance($show_distance)
    {
        $this->container['show_distance'] = $show_distance;

        return $this;
    }

    /**
     * Gets text
     *
     * @return string
     */
    public function getText()
    {
        return $this->container['text'];
    }

    /**
     * Sets text
     *
     * @param string $text The text to be displayed to the user.
     *
     * @return $this
     */
    public function setText($text)
    {
        $this->container['text'] = $text;

        return $this;
    }

    /**
     * Gets total_hits
     *
     * @return int
     */
    public function getTotalHits()
    {
        return $this->container['total_hits'];
    }

    /**
     * Sets total_hits
     *
     * @param int $total_hits The number of products that the search result should contain when this facet element is selected.
     *
     * @return $this
     */
    public function setTotalHits($total_hits)
    {
        $this->container['total_hits'] = $total_hits;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
